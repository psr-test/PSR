package com.serverless.model;

import com.amazonaws.services.dynamodbv2.AmazonDynamoDB;
import com.amazonaws.services.dynamodbv2.datamodeling.*;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;
import com.serverless.DynamoDBAdapter;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.lang.invoke.MethodHandles;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;


@DynamoDBTable(tableName = "PLACEHOLDER_bookS_TABLE_NAME")
public class Book {

    private static final String TABLE_NAME = System.getenv("BOOKS_TABLE_NAME");
    private static final Logger logger = LogManager.getLogger(MethodHandles.lookup().lookupClass());
    private static final DynamoDBAdapter dbAdapter;
    private static final DynamoDBMapper mapper;
    private static final AmazonDynamoDB client;
    private String id;
    private String name;
    private Integer copies;

    static {
        DynamoDBMapperConfig mapperConfig = DynamoDBMapperConfig.builder()
                .withTableNameOverride(new DynamoDBMapperConfig.TableNameOverride(TABLE_NAME))
                .build();
        dbAdapter = DynamoDBAdapter.getInstance();
        mapper = dbAdapter.createDbMapper(mapperConfig);
        client = dbAdapter.getClient();
    }

    public Book() { }

    @DynamoDBHashKey(attributeName = "id")
    @DynamoDBAutoGeneratedKey
    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }

    @DynamoDBRangeKey(attributeName = "name")
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    @DynamoDBAttribute(attributeName = "copies")
    public Integer getCopies() {
        return copies;
    }
    public void setCopies(Integer copies) {
        this.copies = copies;
    }

    public static List<Book> list() {
        DynamoDBScanExpression scanExp = new DynamoDBScanExpression();
        List<Book> results = mapper.scan(Book.class, scanExp);
        for (Book book : results) {
            logger.info("Books - list(): " + book.toString());
        }
        return results;
    }

    public static Optional<Book> get(String id) {
        Map<String, AttributeValue> av = Collections.singletonMap(":v1", new AttributeValue().withS(id));

        DynamoDBQueryExpression<Book> queryExp = new DynamoDBQueryExpression<Book>()
                .withKeyConditionExpression("id = :v1")
                .withExpressionAttributeValues(av);

        PaginatedQueryList<Book> result = mapper.query(Book.class, queryExp);

        Book book;
        if (!result.isEmpty()) {
            book = result.get(0);
            logger.info("Books - get(): book - " + book.toString());
            return Optional.of(book);
        } else {
            logger.info("Books - get(): book - Not Found.");
            return Optional.empty();
        }
    }

    public void save() {
        logger.info("Books - save(): " + toString());
        mapper.save(this);
    }

    public static boolean delete(String id) {
        Optional<Book> book = get(id);
        if (book.isPresent()) {
            logger.info("Books - delete(): " + book.get().toString());
            mapper.delete(book.get());
            return true;
        } else {
            logger.info("Books - delete(): book - does not exist.");
            return false;
        }
    }

    public synchronized void borrow() {
        if (copies > 0) {
            copies -= 1;
        } else {
            throw new RuntimeException("Not enough copies to borrow");
        }
    }

    public synchronized void giveBack() {
        copies += 1;
    }
}